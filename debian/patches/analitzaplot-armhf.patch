Index: analitza/analitzaplot/plotter3d.cpp
===================================================================
--- analitza.orig/analitzaplot/plotter3d.cpp	2013-07-14 12:51:10.799543998 +0200
+++ analitza/analitzaplot/plotter3d.cpp	2013-07-14 12:52:46.291730057 +0200
@@ -142,6 +142,12 @@
     renderGL();
 }
 
+// add overloaded functions which call the underlying OpenGL function
+inline void glMultMatrix(const GLfloat  *m) { glMultMatrixf(m); }
+inline void glMultMatrix(const GLdouble *m) { glMultMatrixd(m); }
+
+inline void glMultMatrix(const QMatrix4x4 &m) { glMultMatrix(m.constData()); }
+
 void Plotter3D::drawPlots()
 {
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
@@ -152,7 +158,7 @@
 
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
-    glMultMatrixd(m_rot.data());
+    glMultMatrix(m_rot);
 
     // Object Drawing :
     glCallList(m_sceneObjects.value(Axes));
@@ -396,6 +402,9 @@
     renderGL();
 }
 
+inline void glGetModelMatrix(float *matrix) { glGetFloatv(GL_MODELVIEW_MATRIX, matrix); }
+inline void glGetModelMatrix(double *matrix) { glGetDoublev(GL_MODELVIEW_MATRIX, matrix); }
+
 void Plotter3D::rotate(int dx, int dy)
 {
     GLdouble ax = -dy;
@@ -410,9 +419,9 @@
         m_rot.rotate(angle, m_rotFixed.normalized());
         renderGL();
     } else {
-        GLdouble matrix[16] = {0}; // model view matrix from current OpenGL state
+        qreal matrix[16] = {0}; // model view matrix from current OpenGL state
 
-        glGetDoublev(GL_MODELVIEW_MATRIX, matrix);
+        glGetModelMatrix(matrix);
 
         QMatrix4x4 matrix4(matrix);
         bool couldInvert;
